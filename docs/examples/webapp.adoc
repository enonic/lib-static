[[example-webapp]]
= Webapp with lib-router

NOTE: This example depends on link:https://market.enonic.com/vendors/enonic/router-lib[lib-router] version 3.0.0 or higher.

Lib-static can also be used to serve assets on URIs directly below an link:https://developer.enonic.com/docs/xp/stable/runtime/engines/webapp-engine#webapp_js[XP webapp]. For example, let's make a simple webapp accessible at URL `<webappRoot>` that serves its own frontend assets at `<webappRoot>/static/*`.

link:https://market.enonic.com/vendors/enonic/router-lib[Lib-router] is used to *add sub-routes under the webapp's root URL*, for example the route `<webappUrl>/static`. Lib-router can extract deeper sub-URIs below that, for example `<webappUrl>/static/css/styles.css`. This sub-URI is then isolated (`"css/styles.css"`) and added to the `request` object, under `request.pathParams` - as `.libRouterPath` in the example below.

*Bottom line:* Combined with lib-router like this, <<path#example-getcleanpath, .getCleanPath>> can just fetch and return `request.pathParams.libRouterPath`, and the `.getCleanPath` <<path#example-gotchas, gotchas>> are automatically handled (except for index fallback at the root - more on that <<#index-fallback-route, here>>).

.src/main/resources/webapp/webapp.js:
[source,javascript,options="nowrap"]
----
const libStatic = require('/lib/enonic/static');

const libRouter = require('/lib/router')();

// Asking lib-router to handle all requests from here on
exports.all = function(request) {
    return libRouter.dispatch(request);
};

// Set up a lib-static getter that fetches files below the 'static' folder...
const getStatic = libStatic.buildGetter(
    {
        root: 'static',
        getCleanPath: request => request.pathParams.libRouterPath
    }
);

// ...which will respond at the route <webappRoot>/static/.+
// The .+ part is a mandatory sub-URI below static/,
// and is inserted into request.pathParams.libRouterPath:
libRouter.get(
    '/static/{libRouterPath:.+}',
    request => getStatic(request)
);


// The main webapp, at <webappRoot>:
libRouter.get(

    // lib-router 3.+ syntax for matching the webapp root,
    // with an optional trailing slash:
    '/?',

    request => {

        // In order to ensure that the relative urls below work,
        // webapp root without a trailing slash is redirected to the same address WITH a slash:
        if (!(req.rawPath || '').endsWith('/')) {
            return {
                redirect: req.path + '/'
            }
        }

        return {
            body: '
                <html>
                    <head>
                        <title>Webapp</title>
                        <link href="static/styles.css" rel="stylesheet" type="text/css" />
                    </head>

                    <body>
                        <h1>My webapp</h1>
                        <img src="static/images/my-logo.jpg" />
                    </body>
                </html>'
        };
    }
);
----

{zwsp} +

[[index-fallback-route]]
==== a) Special case - webapp route with root-index-fallback

The way lib-router works, only defining `'/static/{libRouterPath:.+}'` will make it respond to sub-URIs after `static/` - that is, _both the slash and some sub-URI is required_. So in the example above, lib-static's <<../api/index#index-fallback, index fallback functionality>> is supported _below_ the actual route (for example, `<webappRoot>/static/subfolder` would serve a file _/static/subfolder/index.html_ if it existed), but the route will not match `<webappRoot>/static` or `<webappRoot>/static/` (so they will just return a 404).

Let's say we for some reason wanted that route to use index fallback at the root of `/static`, not only handle the sub-URIs. More precisely, we want to expand the example above so that lib-static can make `<webappRoot>/static` redirect to `<webappRoot>/static/`, and `<webappRoot>/static/` respond with (the contents of) a file `static/index.html`.

For this, we'll add a second route at the root (stay with me here), by *setting up lib-router with an array* instead of a string. The added item has an optional trailing slash `/?`, so it's activated at `/static` as well as `/static/`:

.src/main/resources/webapp/webapp.js:
[source,javascript,options="nowrap"]
----

// ...

libRouter.get(
    [
        '/static/?',
        '/static/{libRouterPath:.+}',
    ]
    request => getStatic(request)
);

// ...
----

Now, on `<webappRoot>/static` and `<webappRoot>/static/`, lib-router matches with the new item in the route array, `'/static/?'`. But since `libRouterPath` is not defined in that item, it means `request.pathParams.libRouterPath` will be `undefined` at the root. So according to the <<path#example-gotchas, criteria>> for `getCleanPath`, *we must also update the `getCleanPath` function* in the lib-static getter.

In order to return `""` for `<webappRoot>/static`, and `"/"` for `<webappRoot>/static/`, what `getCleanPath` needs to do is to return `request.pathParams.libRouterPath` if it a value, and if not, return an empty string at `<webappRoot>/static` and a slash at `<webappRoot>/static/`. The easiest is to just see if `request.rawPath` ends with a slash or not.

The final adjustment to the webapp looks like this:

.src/main/resources/webapp/webapp.js:
[source,javascript,options="nowrap"]
----
// ...

const getStatic = libStatic.buildGetter(
    {
        root: 'static',
        getCleanPath: request => (
            request.pathParams.libRouterPath ||
            (request.rawPath.endsWith("/")
                    ? "/"
                    : ""
            )
        ),
    }
);

libRouter.get(
    [
        '/static/?',
        '/static/{libRouterPath:.+}',
    ]
    request => getStatic(request)
);

// ...
----

Now, a file static/index.html will be served at `<webappRoot>/static/`, with automatic redirect from `<webappRoot>/static`.

{zwsp} +

==== b) Special case - avoid overlapping with /assets/ files

NOTE: The following applies to XP 7, and may be subject to change in XP 8 (but not before, since it's breaking behaviour).

In the current versions of enonic XP, the webapp engine is set up so that if some path `<webappRoot>/my/path.ext` matches a file in the _assets_ folder, _src/main/resources/assets/my/path.ext_, then the engine will give that *priority over the webapp.js controller and directly serve that file instead*.

In other words, if a file called _assets/subpath_ exists, and you use the examples and patterns above to define your own route `libRouter.get('subpath'), ...` then at `<webappRoot>/subpath` your route will be ignored and you will get the file from the asset service instead. Confusion may ensue.

So *avoid defining routes that may overlap with sub-paths to existing files under _src/main/resources/assets/$$*$$_*.

[TIP]
====
The same thing goes for the pattern `$$_/asset$$/*` (which is link:https://developer.enonic.com/docs/xp/stable/runtime/engines/asset-service#asset_files[better documented]).

For example, `<webappRoot>/$$_$$/asset/my/path.ext` will serve _/assets/my/path.ext_ and ignore your `libRouter.get('/$$_$$/asset/{subUri: .+}'), ...`.

But starting with an underscore, this is far easier to handle - just avoid defining routes starting with `$$_$$/asset/`, or with an underscore in the first place.
====
